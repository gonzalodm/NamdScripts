'''
This code generate the spectrum from DFTB+ output
'''

# Modules
import sys
import os
import re
import argparse
import numpy as np
import matplotlib.pyplot as plt
from scipy.signal import find_peaks
from operator import itemgetter

# Inputs, Global constants:
inputs = {}
inputs['found_uv_section'] = False
inputs['w_nm'] = 1.   # Line width for broadening in nm, FWHM

def read_single_output(filename):
    """
      This routine read all the excitations from a single output of dftb
    """
    rawdata = []
    try:
        input_file = open(filename,"r")
        infile = input_file.readlines()
        input_file.close()
        for iline in range(5,len(infile)):
            line = infile[iline].split()
            if line:
                freq = float(line[0])
                ints = float(line[1])
                rawdata.append((freq,ints))
    except IOError:
        print(f"'{filename}'" + " not found")
        sys.exit(1)

    return rawdata

def change_freq_units(data,units):
    new_data = []
    # The freq are at this point in eV, so we need to change only if we want nm
    if units == 'nm':
        for ff, ii in data:
            new_data.append((45.56335/(ff/27.2114),ii))

    elif units == "eV":
        for ff, ii in data:
            new_data.append((ff,ii))

    return new_data

def gauss(a,m,x,w):                                                                                                                     
    # calculation of the Gaussian line shape 
    # a = amplitude (max y, intensity) 
    # x = position
    # m = maximum/meadian (stick position in x, wave number)
    # w = line width, FWHM
    return a*np.exp(-(np.log(2)*((m-x)/w)**2))

def main():
    # Init arguments
    parser = argparse.ArgumentParser(prog='dftb_uv', description='Easily plot absorption spectra from dftb+ code')

    # Filename argument is mandatory
    parser.add_argument("filename", help="The EXC.DAT output file generated by DFTB+ or the path to the differents EXC.DAT")

    # Show the plot window
    parser.add_argument('-s','--show', default=False, action='store_true',help='Show the plot window')

    # Units of the final figure for the spectra. The default unit is nm
    parser.add_argument('-u','--units', type=str, default='nm' , help='Units for the spectra: nm or eV')

    # Set the FWHM for the spectra in the same units that you choose before. The default value is 5 nm
    parser.add_argument('-wn','--linewidth', type=float, help='Line width for broadening - Same [units] units')

    # Active the multiplies mode
    parser.add_argument('-mul','--multiple', default=False, action='store_true', help='Active the multiple read files mode')

    # Read Only first Transition
    parser.add_argument('-f','--first', default=False, action='store_true', help='Read Only first transition')

    # Normalization of the final spectra
    parser.add_argument('-n','--normalize', default=True, action='store_false', help='Normalization of the final spectra')

    # Show individual transitions
    parser.add_argument('-ind','--individual', default=False, action='store_true', help='Show individual transition')

    # Way to show individual transitions: bar or gaussian
    parser.add_argument('-way','--wayindiv', type=str, default='bar' , help='The individual transitions are shown like bar or gaussian')

    # TODO: add more arguments for init, end, etc

    # Set Arguments
    args = parser.parse_args()
    inputs['filename']   = args.filename
    inputs['units']      = args.units
    inputs['multiple']   = args.multiple
    inputs['first']      = args.first
    inputs['normalize']  = args.normalize
    inputs['individual'] = args.individual
    inputs['wayindiv']   = args.wayindiv
    inputs['show']       = args.show

    # Set units and other things related to that
    if inputs['units'] == 'nm':
        inputs['step_freq'] = 1
        if args.linewidth:
            inputs['wn'] = args.linewidth
        else:
            inputs['wn'] = 5.
    elif inputs['units'] == 'eV':
        inputs['step_freq'] = 0.01
        if args.linewidth:
            inputs['wn'] = args.linewidth
        else:
            inputs['wn'] = 0.15
    else:
        print(f"'{units}'" + " not implemented. Only nm or eV")
        sys.exit(1)

    # Read the output. The units here are in eV (The units used by dftb)
    if inputs['multiple']:
        rawdataall = []
        for ii in range(101):
            name = os.path.join(inputs['filename'] + str(ii),'EXC.DAT')
            rawdata = read_single_output(name)
            if inputs['first']:
                rawdataall.append(rawdata[0])
            else:
                rawdataall.extend(rawdata)
        inputs['rawdata'] = rawdataall
    else:
        rawdata = read_single_output(inputs['filename'])
        if inputs['first']:
            inputs['rawdata'] = rawdata[0]
        else:
            inputs['rawdata'] = rawdata

    # Here we change the units
    inputs['rawdata'] = change_freq_units(inputs['rawdata'],inputs['units'])

    # We will construct the plot on the fly.!
    fig, ax = plt.subplots()

    # We construct the gaussian shape
    inputs['maxfreq'] = max(inputs['rawdata'], key = itemgetter(0))[0] + inputs['wn'] * 3
    inputs['minfreq'] = min(inputs['rawdata'], key = itemgetter(0))[0] - inputs['wn'] * 3

    plt_range_x=np.arange(0,inputs['maxfreq'],inputs['step_freq'])
    gaussian_sum = []

    for freq, ints in inputs['rawdata']:
        single_gauss = gauss(ints,plt_range_x,freq,inputs['wn'])
        gaussian_sum.append(single_gauss)

        # Plot individual gaussian
        if inputs['individual']:
            if inputs['wayindiv'] == 'gaussian':
                ax.plot(plt_range_x,single_gauss,color='grey',alpha=0.5)
            elif inputs['wayindiv'] == 'bar':
                ax.vlines(x=freq, ymin=0., ymax=ints, colors='grey', lw=2, alpha=0.5)
            else:
                print('The option [%s] for individual transitions is wrong. Only [bar] or [gaussian]' % (inputs['wayindiv']))
                sys.exit(1)

    # Get the sum of all the gaussian, normalize by the number of data and to 1.
    plt_range_gauss_sum_y = np.sum(gaussian_sum,axis=0) / len(inputs['rawdata'])
    if inputs['normalize']:
        plt_range_gauss_sum_y /= np.max(plt_range_gauss_sum_y)
    
    # Finds the maximum
    peaks, _ = find_peaks(plt_range_gauss_sum_y,height=0)

    # Plot the average spectra with the maximums peaks
    ax.plot(plt_range_x,plt_range_gauss_sum_y,color="black",linewidth=1.0)
    for index, txt in enumerate(peaks):
        ax.annotate(plt_range_x[peaks[index]],xy=(plt_range_x[peaks[index]],plt_range_gauss_sum_y[peaks[index]]),ha="center",
                rotation=90,size=8,xytext=(0,5), textcoords='offset points')

    # Set labels and titles
    ax.set_xlabel('Frequency [%s]' % (inputs['units']))
    ax.set_ylabel('Intensity [a.u.]')
    ax.set_title('Absorption Spectra')
    plt.tight_layout()

    # Set start and end x axis
    plt.xlim(inputs['minfreq'],inputs['maxfreq'])

    # Save/Show fig
    plt.savefig("absorption_dftb.pdf",dpi=300)
    if inputs['show']:
        plt.show()



if __name__ == '__main__':
    main()
